        -:    0:Source:arvore.c
        -:    0:Graph:arvore.gcno
        -:    0:Data:arvore.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/**
        -:    2: * Implementação das operações sobre
        -:    3: * a árvore
        -:    4: */
        -:    5:
        -:    6:#include "includes/arvore.h"
        -:    7:#include <stdio.h>
        -:    8:#include <string.h>
        -:    9:#include <stdlib.h>
        -:   10:
       58:   11:node* createNode(char const *data) 
        -:   12:{
       58:   13:	node *new_node = (struct node*) malloc(sizeof(struct node));
       58:   14:	strcpy(new_node->text, data);
       58:   15:	new_node->left = new_node->right = NULL;
       58:   16:	new_node->depth = 0;
       58:   17:	return new_node;
        -:   18:}
        -:   19:
       14:   20:node* createTree(void) 
        -:   21:{
        -:   22:	node *root, *sim, *nao;
        -:   23:
       14:   24:	root = createNode("É um animal?\n");
       14:   25:	sim = createNode("gato\n");
       14:   26:	nao = createNode("árvore\n");
       14:   27:	root->left = sim;
       14:   28:	root->right = nao;
       14:   29:	root->depth = 1;
       14:   30:}
        -:   31:
      145:   32:void freeTree(node* root)
        -:   33:{
      145:   34:	if (root == NULL) 
        -:   35:	{
       88:   36:		return;
        -:   37:	}
        -:   38:
       57:   39:	freeTree(root->left);
       57:   40:	freeTree(root->right);
       57:   41:	free(root);
        -:   42:}
        -:   43:
        7:   44:int insert(node *parent, node *son, int branch)
        -:   45:{
        7:   46:	switch (branch)
        -:   47:	{
        -:   48:		case 0:
        3:   49:			if (parent->left != NULL)
        -:   50:			{
        1:   51:				break;
        -:   52:			}
        2:   53:			parent->left = son;
        2:   54:			son->depth = parent->depth + 1;
        2:   55:			return 0;
        -:   56:		case 1:
        2:   57:			if (parent->right != NULL)
        -:   58:			{
    #####:   59:				break;
        -:   60:			}
        2:   61:			parent->right = son;
        2:   62:			son->depth = parent->depth + 1;
        2:   63:			return 0;
        -:   64:		default:
        2:   65:			return 1;
        -:   66:	}
        1:   67:}
        -:   68:
        8:   69:int removeNode(node *parent, node *son)
        -:   70:{
        8:   71:	if(parent->left != son && parent->right != son)
        -:   72:	{
        2:   73:		return 1;
        -:   74:	}
        -:   75:
        6:   76:	if(parent->left == son)
        -:   77:	{
        3:   78:		parent->left = NULL;
        -:   79:	}
        -:   80:	else
        -:   81:	{
        3:   82:		parent->right = NULL;
        -:   83:	}
        -:   84:
        6:   85:	freeTree(son);
        6:   86:	return 0;
        -:   87:}
        -:   88:
    #####:   89:void save(node *root, FILE *fp)
        -:   90:{
    #####:   91:	if(root == NULL)
        -:   92:	{
    #####:   93:		fprintf(fp, "-1\n");
    #####:   94:		return;
        -:   95:	}
        -:   96:
    #####:   97:	fprintf(fp, "%s", root->text);
    #####:   98:	save(root->left, fp);
    #####:   99:	save(root->right, fp);
        -:  100:}
