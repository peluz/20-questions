        -:    0:Source:arvore.c
        -:    0:Graph:arvore.gcno
        -:    0:Data:arvore.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * Implementação das operações sobre
        -:    3: * a árvore
        -:    4: */
        -:    5:
        -:    6:#include "includes/arvore.h"
        -:    7:#include <stdio.h>
        -:    8:#include <string.h>
        -:    9:#include <stdlib.h>
        -:   10:
       58:   11:node* createNode(char const *data) 
        -:   12:{
       58:   13:	node *new_node = (struct node*) malloc(sizeof(struct node));
       58:   14:	printf("%s", data);
       58:   15:	strcpy(new_node->text, data);
       58:   16:	new_node->left = new_node->right = NULL;
       58:   17:	new_node->depth = 0;
        -:   18:	return new_node;
        -:   19:}
       14:   20:
        -:   21:node* createTree(void) 
        -:   22:{
        -:   23:	node *root, *sim, *nao;
       14:   24:
       14:   25:	root = createNode("É um animal?\n");
       14:   26:	sim = createNode("É um gato!\n");
       14:   27:	nao = createNode("É uma árvore!\n");
       14:   28:	root->left = sim;
       14:   29:	root->right = nao;
       14:   30:	root->depth = 1;
        -:   31:}
      145:   32:
        -:   33:void freeTree(node* root)
      145:   34:{
        -:   35:	if (root == NULL) 
       88:   36:	{
        -:   37:		return;
        -:   38:	}
       57:   39:
       57:   40:	freeTree(root->left);
       57:   41:	freeTree(root->right);
        -:   42:	free(root);
        -:   43:}
        7:   44:
        -:   45:int insert(node *parent, node *son, int branch)
        7:   46:{
        -:   47:	switch (branch)
        -:   48:	{
        3:   49:		case 0:
        -:   50:			if (parent->left != NULL)
        1:   51:			{
        -:   52:				break;
        2:   53:			}
        2:   54:			parent->left = son;
        2:   55:			son->depth = parent->depth + 1;
        -:   56:			return 0;
        2:   57:		case 1:
        -:   58:			if (parent->right != NULL)
    #####:   59:			{
        -:   60:				break;
        2:   61:			}
        2:   62:			parent->right = son;
        2:   63:			son->depth = parent->depth + 1;
        -:   64:			return 0;
        2:   65:		default:
        -:   66:			return 1;
        1:   67:	}
        -:   68:}
        8:   69:
        -:   70:int removeNode(node *parent, node *son)
        8:   71:{
        -:   72:	if(parent->left != son && parent->right != son)
        2:   73:	{
        -:   74:		return 1;
        -:   75:	}
        6:   76:
        -:   77:	if(parent->left == son)
        3:   78:	{
        -:   79:		parent->left = NULL;
        -:   80:	}
        -:   81:	else
        3:   82:	{
        -:   83:		parent->right = NULL;
        -:   84:	}
        6:   85:
        6:   86:	freeTree(son);
        -:   87:	return 0;
        -:   88:}
        -:   89:
        -:   90:void save(node *root, FILE *fp)
        -:   91:{
        -:   92:	if(root == NULL)
        -:   93:	{
        -:   94:		fprintf(fp, "-1\n");
        -:   95:		return;
        -:   96:	}
        -:   97:
        -:   98:	fprintf(fp, "%s", root->text);
        -:   99:	save(root->left, fp);
        -:  100:	save(root->right, fp);
        -:  101:}
        -:  102:
        -:  103:void load(node *root, FILE* fp)
        -:  104:{
        -:  105:	char text[150];
        -:  106:
        -:  107:	if (fgets(text, 150, fp) == NULL)
        -:  108:	{
        -:  109:		printf("hey\n");
        -:  110:		return;
        -:  111:	}
        -:  112:
        -:  113:	if (strcmp(text, "-1\n") == 0)
        -:  114:	{
        -:  115:		return;
        -:  116:	}
        -:  117:
        -:  118:	root = createNode(text);
        -:  119:	load(root->left, fp);
        -:  120:	load(root->right, fp);
        -:  121:}
